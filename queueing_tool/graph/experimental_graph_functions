import graph_tool.all as gt
import numpy   as np

from .graph_preparation import add_edge_lengths


def _test_graph(g) :
    """A function that makes sure ``g`` is either a :class:`~graph_tool.Graph` or
     a string or file object to one.

    Parameters
    ----------
    g : A **str** or a :class:`~graph_tool.Graph`.

    Returns
    -------
    :class:`~graph_tool.Graph`
        If ``g`` is a string or a file object then the output given by
        ``graph_tool.load_graph(g, fmt='xml')``, if ``g`` is aready a
        :class:`~graph_tool.Graph` then it is returned unaltered.

    Raises
    ------
    TypeError
        Raises a :exc:`~TypeError` if ``g`` is not a string to a file object,
        or a :class:`~graph_tool.Graph`\.
    """
    if isinstance(g, str) :
        g = gt.load_graph(g, fmt='xml')
    elif not isinstance(g, gt.Graph) :
        raise TypeError("Need to supply a graph-tool graph or the location of a graph")
    return g


def osm_edge_types(g) :
    """A function that takes graphs created using open street maps and formsts
    them for use with the :class:`.QueueNetwork` class.

    Made specifically for a :class:`~graph_tool.Graph` created using data from
    `openstreetmaps <www.openstreetmaps.org>`_. Graphs from openstreetmaps
    sometimes have tags for certain nodes (like the latitude and longitude),
    or whether a location is an attraction. This function uses some of that
    information to set a :class:`~graph_tool.Graph`'s ``eType`` and
    ``edge_length`` edge properties.

    Parameters
    ----------
    g : A **str** or a :class:`~graph_tool.Graph`.

    Returns
    -------
    :class:`~graph_tool.Graph`
        Returns the :class:`~graph_tool.Graph` ``g`` with the ``eType`` and
        ``edge_length`` edge properties.

    Raises
    ------
    TypeError
        Raises a :exc:`~TypeError` if ``g`` is not a string to a file object,
        or a :class:`~graph_tool.Graph`\.
    """
    g = _test_graph(g)

    g.reindex_edges()
    vertex_props = set()
    for key in g.vertex_properties.keys() :
        vertex_props.add(key)

    edge_props = set()
    for key in g.edge_properties.keys() :
        edge_props.add(key)

    has_garage  = 'garage' in vertex_props
    has_destin  = 'destination' in vertex_props
    has_light   = 'light' in vertex_props
    has_egarage = 'garage' in edge_props
    has_edestin = 'destination' in edge_props
    has_elight  = 'light' in edge_props

    eType   = g.new_edge_property("int")
    for v in g.nodes() :
        if has_garage and g.vp['garage'][v] :
            e = g.edge(v,v)
            if isinstance(e, gt.Edge) :
                eType[e]  = 1
        if has_destin and g.vp['destination'][v] :
            e = g.edge(v,v)
            if isinstance(e, gt.Edge) :
                eType[e]  = 2
        if has_light and g.vp['light'][v] :
            e = g.edge(v,v)
            if isinstance(e, gt.Edge) :
                eType[e]  = 3

    for e in g.edges() :
        if has_egarage and g.ep['garage'][e] :
            eType[e]  = 1
        if has_edestin and g.ep['destination'][e] :
            eType[e]  = 2
        if has_elight and g.ep['light'][e] :
            eType[e]  = 3

    g.ep['eType'].a = eType.a + 1
    return add_edge_lengths(g)


def _shortest_paths(g) :
    """Returns the shortest paths between every two vertices in the graph ``g``,
    as well as the total distances along those distances.

    This function assumes an ``edge_length`` edge property is attached to the
    graph.

    Parameters
    ----------
    g : Graph
        A connected :class:`~graph_tool.Graph`.

    Returns
    -------
    shortest_path : :class:`~numpy.ndarray`
        A two-dimensional array where ``shortest_path[i,j]`` is the next vertex
        to visit if you want to take the shortest path from node ``i`` to node
        ``j``.
    distances : :class:`~numpy.ndarray`
        A two-dimensional array where ``distances[i,j]`` is the distance of the
        shortest path from node ``i`` to node ``j``.

    Raises
    ------
    TypeError
        Raises a :exc:`~TypeError` if ``g`` is not a string to a file object, or a
        :class:`~graph_tool.Graph`.
    """
    g = _test_graph(g)

    v_props = set()
    for key in g.vertex_properties.keys() :
        v_props = v_props.union([key])

    nV    = g.number_of_nodes()
    dist  = np.zeros((nV, nV))
    short = np.ones( (nV, nV), int)
    spath = np.ones( (nV, nV), int)

    if 'dist' not in v_props :
        for ve in g.nodes() :
            for we in g.nodes() :
                v,w  = int(ve), int(we)

                if v == w or dist[v, w] != 0 :
                    continue

                tmp   = gt.shortest_path(g, ve, we, weights=g.ep['edge_length'])
                path  = [int(v) for v in tmp[0]]
                elen  = [g.ep['edge_length'][e] for e in tmp[1]]

                for i in range(len(path) - 1):
                    for j in range(i+1, len(path)):
                        dist[path[i], path[j]] = sum(elen[i:j])

                spath[path[:-1], path[-1]] = path[1:]

                for j in range(1,len(path)-1) :
                    pa  = path[:-j]
                    spath[pa[:-1], pa[-1]] = pa[1:]

                if not g.is_directed() :
                    path.reverse()
                    spath[path[:-1], path[-1]] = path[1:]

                    for j in range(1, len(path)-1) :
                        pa  = path[:-j]
                        spath[pa[:-1], pa[-1]] = pa[1:]

            short[v, :] = spath[v, :]

        r = np.arange(nV)
        short[r, r] = r
    else :
        for v in g.nodes() :
            dist[int(v),:] = g.vp['dist'][v].a

    return short, dist
